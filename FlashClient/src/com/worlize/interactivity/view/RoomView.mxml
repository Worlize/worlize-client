<?xml version="1.0" encoding="utf-8"?>
<!-- width="{backgroundImage.width}" height="{backgroundImage.height}" -->
<s:Group xmlns:mx="library://ns.adobe.com/flex/halo"
	clipAndEnableScrolling="true"
	currentState="normal"
	creationComplete="handleCreationComplete()"
	enterFrame="handleEnterFrame()"
	width="950" height="570"
	scaleX="{scaleFactor}"
	scaleY="{scaleFactor}"
	xmlns:view="com.worlize.interactivity.view.*"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:mx1="library://ns.adobe.com/flex/mx">

	<s:layout>
		<s:BasicLayout />
	</s:layout>

	<fx:Metadata>
		[Event(name="securityError", type="com.worlize.interactivity.event.InteractivitySecurityErrorEvent")]
	</fx:Metadata>
	
	<s:states>
		<s:State name="normal" />
		<s:State name="unableToLoadBackground" />
	</s:states>
	
	<fx:Script>
		<![CDATA[
			import com.flashandmath.dg.display.SnowDisplay;
			import com.worlize.command.ApplyModerationRestrictionCommand;
			import com.worlize.command.BlessUserAsModeratorCommand;
			import com.worlize.command.GetAnotherAppCopyCommand;
			import com.worlize.command.UnblessUserAsModeratorCommand;
			import com.worlize.components.visualnotification.VisualNotification;
			import com.worlize.event.NotificationCenter;
			import com.worlize.interactivity.event.AvatarSelectEvent;
			import com.worlize.interactivity.event.ChatEvent;
			import com.worlize.interactivity.event.InteractivitySecurityErrorEvent;
			import com.worlize.interactivity.event.RoomEvent;
			import com.worlize.interactivity.iptscrae.command.CLIENTTYPECommand;
			import com.worlize.interactivity.model.ChatBubbleStyle;
			import com.worlize.interactivity.model.ChatMessage;
			import com.worlize.interactivity.model.CurrentRoom;
			import com.worlize.interactivity.model.Hotspot;
			import com.worlize.interactivity.model.InteractivityConfig;
			import com.worlize.interactivity.model.InteractivityUser;
			import com.worlize.interactivity.model.LooseProp;
			import com.worlize.interactivity.model.UserPermission;
			import com.worlize.interactivity.model.UserRestriction;
			import com.worlize.interactivity.model.WebcamBroadcastManager;
			import com.worlize.interactivity.rpc.InteractivityClient;
			import com.worlize.model.App;
			import com.worlize.model.AppInstance;
			import com.worlize.model.RoomDefinition;
			import com.worlize.model.friends.FriendsList;
			import com.worlize.model.friends.FriendsListEntry;
			import com.worlize.model.userSearch.UserSearchResultLineItem;
			import com.worlize.notification.WorlizeNotification;
			import com.worlize.rpc.WorlizeResultEvent;
			import com.worlize.state.AuthorModeState;
			import com.worlize.video.control.NetConnectionManager;
			
			import mx.binding.utils.ChangeWatcher;
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Menu;
			import mx.core.DragSource;
			import mx.core.FlexBitmap;
			import mx.core.IUIComponent;
			import mx.core.IVisualElement;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.EffectEvent;
			import mx.events.FlexEvent;
			import mx.events.MenuEvent;
			import mx.events.PropertyChangeEvent;
			import mx.formatters.DateFormatter;
			import mx.graphics.codec.JPEGEncoder;
			import mx.logging.ILogger;
			import mx.logging.Log;
			import mx.managers.DragManager;
			
			import spark.effects.Animate;
			import spark.effects.Fade;
			import spark.effects.Move;
			
			private var logger:ILogger = Log.getLogger('com.worlize.interactivity.view.RoomView');
			
			private var _scaleFactor:Number = 1.0;
			
			private var _room:CurrentRoom;
			private var roomBackgroundWatcher:ChangeWatcher;
			
			private var snowfallWatcher:ChangeWatcher;
					
			private var avatarsByUser:Dictionary = new Dictionary();
			private var nameTagsByUser:Dictionary = new Dictionary();
			
			private var currentMenu:Menu;
			
			private var snowPlaying:Boolean = false;
			private var snow:SnowDisplay;
			
			private var _webcamBroadcastManager:WebcamBroadcastManager;
			private var _netConnectionManager:NetConnectionManager;
			
			[Bindable(event="webcamBroadcastManagerChanged")]
			public function set webcamBroadcastManager(newValue:WebcamBroadcastManager):void {
				if (_webcamBroadcastManager !== newValue) {
					_webcamBroadcastManager = newValue;
					// Update existing avatar instances
					for (var userGuid:String in avatarsByUser) {
						var avatar:Avatar = avatarsByUser[userGuid];
						if (avatar) {
							avatar.webcamBroadcastManager = newValue;
						}
					}
					dispatchEvent(new FlexEvent("webcamBroadcastManagerChanged"));
				}
			}
			public function get webcamBroadcastManager():WebcamBroadcastManager {
				return _webcamBroadcastManager;
			}
			
			[Bindable(event="netConnectionManagerChanged")]
			public function set netConnectionManager(newValue:NetConnectionManager):void {
				if (_netConnectionManager !== newValue) {
					_netConnectionManager = newValue;
					// Update existing avatar instances
					for (var userGuid:String in avatarsByUser) {
						var avatar:Avatar = avatarsByUser[userGuid];
						if (avatar) {
							avatar.netConnectionManager = newValue;
						}
					}
					dispatchEvent(new FlexEvent("netConnectionManagerChanged"));
				}
			}
			public function get netConnectionManager():NetConnectionManager {
				return _netConnectionManager;
			}
			
			[Bindable(event="scaleFactorChanged")]
			public function get scaleFactor():Number {
				return _scaleFactor;
			}
			public function set scaleFactor(newValue:Number):void {
				if (_scaleFactor !== newValue) {
					_scaleFactor = newValue;
					updateTextItemScale();
					dispatchEvent(new FlexEvent('scaleFactorChanged'));
				}
			}
			
			[Bindable(event="roomChanged")]
			public function get room():CurrentRoom {
				return _room;
			}
			public function set room(newValue:CurrentRoom):void {
				if (_room && _room !== newValue) {
					_room.removeEventListener(ChatEvent.CHAT, handleChat);
					_room.removeEventListener(ChatEvent.ROOM_MESSAGE, handleChat);
					_room.removeEventListener(ChatEvent.WHISPER, handleChat);
					_room.removeEventListener(RoomEvent.ROOM_CLEARED, handleRoomCleared);
					_room.removeEventListener(RoomEvent.USER_ENTERED, handleUserEntered);
					_room.removeEventListener(RoomEvent.USER_LEFT, handleUserLeft);
					_room.removeEventListener(RoomEvent.USER_MOVED, handleUserMoved);
					_room.removeEventListener(RoomEvent.SELECTED_USER_CHANGED, handleSelectedUserChanged);
					_room.roomView = null;
					roomBackgroundWatcher.unwatch();
				}
				if (_room !== newValue) {
					_room = newValue;
					_room.addEventListener(ChatEvent.CHAT, handleChat);
					_room.addEventListener(ChatEvent.ROOM_MESSAGE, handleChat);
					_room.addEventListener(ChatEvent.WHISPER, handleChat);
					_room.addEventListener(RoomEvent.ROOM_CLEARED, handleRoomCleared);
					_room.addEventListener(RoomEvent.USER_ENTERED, handleUserEntered);
					_room.addEventListener(RoomEvent.USER_LEFT, handleUserLeft);
					_room.addEventListener(RoomEvent.USER_MOVED, handleUserMoved);
					_room.addEventListener(RoomEvent.SELECTED_USER_CHANGED, handleSelectedUserChanged);
					roomBackgroundWatcher = ChangeWatcher.watch(room, 'backgroundFile', handleBGChange);
					snowfallWatcher = ChangeWatcher.watch(room, 'snowEnabled', handleSnowEnabledChange);
					_room.roomView = this;
					updateAvatarTransparencies();
					dispatchEvent(new Event("roomChanged"));
				};
			}
			
			private function handleCreationComplete():void {
				addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown);
				addEventListener(DragEvent.DRAG_ENTER, handleDragEnter);
				addEventListener(DragEvent.DRAG_DROP, handleDragDrop);
				addEventListener(DragEvent.DRAG_OVER, handleDragOver);
				initSnowFall();
			}
			
			private function initSnowFall():void {
				snow = new SnowDisplay(this.width, this.height-26);
				snow.mouseEnabled = false;
				snow.mouseChildren = false;
				snow.x = 0;
				snow.y = 0;
				
				snow.make2D = false;
				snow.particlesToAddEachFrame = 1;
				snow.waitCount = 2;			
				snow.colorToAccelFactorX = 0.0005;
				snow.colorToAccelFactorY = 0.0005;
				snow.randAccelFactorX = 0;
				snow.randAccelFactorY = 0;
				snow.airResistanceFactor = 0.064;
				snow.gravity = 0.025;
				snow.windX = 0;
				snow.windY = 0;
				snow.initYVel = Math.sqrt(snow.gravity/snow.airResistanceFactor);
				snow.minEffect = 1;
				
				snow.maxNumParticles = 600;
				
				snow.minParticleSize = 1.5;
				snow.maxParticleSize = 1.5;
				
				snow.fLen = 600;
				snow.zRange = 500;
				snow.zBack = 0;
				snow.scaleCheat = 0.8;
			}
			
			private function handleSnowEnabledChange(event:PropertyChangeEvent):void {
				if (room.snowEnabled && !snowPlaying) {
					startSnow();
				}
				else if (!room.snowEnabled && snowPlaying) {
					stopSnow();
				}
			}
			
			private function startSnow():void {
				snow.reset();
				snowContainer.addChild(snow);
				snowPlaying = true;
			}
			
			private function stopSnow():void {
				snow.reset();
				snowContainer.removeChild(snow);
				snowPlaying = false;
			}
			
			public function updateTextItemScale():void {
				var inverseScaleFactor:Number = 1 / scaleFactor;
				for (var i:int=0; i < nameTagGroup.numElements; i ++) {
					var element:IVisualElement = nameTagGroup.getElementAt(i);
					if (element is DisplayObject) {
						(element as DisplayObject).scaleX = inverseScaleFactor;
						(element as DisplayObject).scaleY = inverseScaleFactor;
					}
				}
				
				for (i=0; i < textGroup.numElements; i ++) {
					element = textGroup.getElementAt(i);
					if (element is DisplayObject) {
						(element as DisplayObject).scaleX = inverseScaleFactor;
						(element as DisplayObject).scaleY = inverseScaleFactor;
					}
				}
			}
			
			private function handleDragEnter(event:DragEvent):void {
				if (event.dragSource.hasFormat('objectFromLocker') ||
					event.dragSource.hasFormat('propFromLocker') ||
					event.dragSource.hasFormat('appFromLocker') ||
					event.dragSource.hasFormat('appFromLockerRequiresDuplicate') ||
					event.dragSource.hasFormat('objectInRoom') ||
					event.dragSource.hasFormat('propInRoom'))
				{
					DragManager.acceptDragDrop(event.target as IUIComponent);
				}
			}
			
			private function handleDragDrop(event:DragEvent):void {
				var data:Object;
				var client:InteractivityClient = InteractivityClient.getInstance();
				var x:Number = mouseX;
				var y:Number = mouseY;
				
				if (event.dragSource.hasFormat('objectFromLocker')) {
					data = event.dragSource.dataForFormat('objectFromLocker');
					client.addObjectInstance(data.guid, x, y);
				}
				else if (event.dragSource.hasFormat('appFromLocker')) {
					data = event.dragSource.dataForFormat('appFromLocker');
					var appInstance:AppInstance = AppInstance(data.appInstance);
					client.addAppInstance(appInstance.guid, x, y);
				}
				else if (event.dragSource.hasFormat('appFromLockerRequiresDuplicate')) {
					data = event.dragSource.dataForFormat('appFromLockerRequiresDuplicate');
					var command:GetAnotherAppCopyCommand = new GetAnotherAppCopyCommand();
					command.addEventListener(WorlizeResultEvent.RESULT, function(resultEvent:Event):void {
						if (command.state === GetAnotherAppCopyCommand.STATE_COMPLETE) {
							client.addAppInstance(command.appInstance.guid, x, y);
						}
					});
					command.execute(App(data.app));
				}
				else if (event.dragSource.hasFormat('propFromLocker')) {
					data = event.dragSource.dataForFormat('propFromLocker');
					InteractivityClient.getInstance().addLooseProp(data.guid, x, y);
				}
				else if (event.dragSource.hasFormat('propInRoom')) {
					data = event.dragSource.dataForFormat('propInRoom');
					var looseProp:LooseProp = data.looseProp;
					var deltaX:int = event.stageX - data.startMouseX;
					var deltaY:int = event.stageY - data.startMouseY;
					var newX:int = looseProp.x + deltaX;
					var newY:int = looseProp.y + deltaY;
					if (event.action === DragManager.COPY) {
						InteractivityClient.getInstance().addLooseProp(looseProp.prop.guid, newX, newY);
					}
					else {
						InteractivityClient.getInstance().moveLooseProp(looseProp.id, newX, newY);						
					}
				}
			}
			
			private function handleDragOver(event:DragEvent):void {
				if (event.dragSource.hasFormat('objectFromLocker') ||
					event.dragSource.hasFormat('propFromLocker'))
				{
					DragManager.showFeedback(DragManager.COPY);
				}
				else if (event.dragSource.hasFormat('propInRoom')) {
					if (event.altKey || event.ctrlKey) {
						DragManager.showFeedback(DragManager.COPY);
					}
					else {
						DragManager.showFeedback(DragManager.MOVE);
					}
				}
			}
				
			
			private function handleUserMoved(event:RoomEvent):void {
				removeChatBubblesForUser(event.user);
			}
			
			private function handleSelectedUserChanged(event:Event):void {
				updateAvatarTransparencies();
			}
			
			private var draggingAvatar:Boolean = false;
			private var liveDraggingAvatar:Boolean = false;
			private var liveDraggingTimer:Timer = new Timer(100, 0);
			
			private function handleAvatarDragMouseDown(event:MouseEvent):void {
				if (event.currentTarget is Avatar) {
					var user:InteractivityUser = Avatar(event.currentTarget).user;
					if (!user.isSelf) { return; }
				}
				
				if (user.hasActiveRestriction(UserRestriction.PIN)) {
					return;
				}
				
				if (event.shiftKey) {
					liveDraggingTimer.reset();
					liveDraggingTimer.start();
					liveDraggingTimer.addEventListener(TimerEvent.TIMER, handleLiveDraggingTimer);
					liveDraggingAvatar = true;
				}
				startAvatarDrag();
				updateSelfPosition();
			}
			
			private function startAvatarDrag(event:MouseEvent = null):void {
				draggingAvatar = true;
				systemManager.getSandboxRoot().addEventListener(MouseEvent.MOUSE_UP, handleStageMouseUp);
				addEventListener("customMouseMove", handleAvatarDragMouseMove);
			}

			private function stopAvatarDrag():void {
				draggingAvatar = false;
				if (liveDraggingAvatar) {
					liveDraggingAvatar = false;
					liveDraggingTimer.stop();
					liveDraggingTimer.removeEventListener(TimerEvent.TIMER, handleLiveDraggingTimer);
				}
				systemManager.getSandboxRoot().removeEventListener(MouseEvent.MOUSE_UP, handleStageMouseUp);
				removeEventListener("customMouseMove", handleAvatarDragMouseMove);
			}
			
			private function handleMouseDown(event:MouseEvent):void {
				var authorModeState:AuthorModeState = AuthorModeState.getInstance();
				if (authorModeState.enabled) {
					authorModeState.selectedItem = null;
				}
				
				var self:InteractivityUser = room.getSelfUser();
				if (self && self.hasActiveRestriction(UserRestriction.PIN)) {
					return;
				}
				
				updateSelfPosition();
				sendCurrentPositionToServer();
			}
			
			private function sendCurrentPositionToServer():void {
				var self:InteractivityUser = room.getSelfUser();
				if (self) {
					InteractivityClient.getInstance().move(self.x, self.y);
				}
			}
			
			private function updateSelfPosition():void {
				var self:InteractivityUser = room.getSelfUser();
				if (!self) { return; }
				removeChatBubblesForUser(self);
				var x:int = this.contentMouseX;
				var y:int = this.contentMouseY;
				if (x < 22) { x = 22; }
				if (y < 22) { y = 22; }
				if (x > width - 22) { x = width - 22; }
				if (y > height - 22) { y = height - 22; }
				
				self.x = x;
				self.y = y;
			}
			
			private function handleLiveDraggingTimer(event:TimerEvent):void {
				if (liveDraggingAvatar) {
					sendCurrentPositionToServer();
				}
			}
			
			private function handleAvatarDragMouseMove(event:MouseEvent):void {
				if (draggingAvatar) {
					updateSelfPosition();
				}
			}
						
			private function handleStageMouseUp(event:MouseEvent):void {
				stopAvatarDrag();
				sendCurrentPositionToServer();
			}
			
			private function buildModerationMenuItems(targetUser:InteractivityUser):Array {
				var self:InteractivityUser = room.getSelfUser();
				if (!self) { return []; }
				if (!self.hasPermission(UserPermission.CAN_ACCESS_MODERATION_DIALOG)) {
					return [];
				}
				
				var menu:Array = [
					{ type: "separator" }
				];
				
				if (self.hasPermission(UserPermission.CAN_BLESS_MODERATORS) && self.hasPermission(UserPermission.CAN_GRANT_PERMISSIONS)) {
					if (targetUser.id !== InteractivityClient.getInstance().currentWorld.ownerGuid) {
						var isModerator:Boolean = targetUser.hasWorldPermission(UserPermission.CAN_ACCESS_MODERATION_DIALOG);
						menu.push({
							type: "check",
							toggled: isModerator,
							label: "Bless as Moderator",
							user: targetUser,
							action: isModerator ? "unblessModerator": "blessModerator"
						});
						menu.push({ type: "separator" });
					}
				}
				
				var canModerateGlobally:Boolean = self.hasGlobalPermission(UserPermission.CAN_MODERATE_GLOBALLY);
				
				menu.push({
					type: 'normal',
					label: "World Moderation",
					action: 'none',
					children: buildModerationSubmenuItems(targetUser)
				});
				menu.push({
					type: 'normal',
					label: "Global Moderation",
					action: 'none',
					children: buildGlobalModerationSubmenuItems(targetUser, canModerateGlobally)
				});
				
				return menu;
			}
			
			private function buildModerationSubmenuItems(targetUser:InteractivityUser, allowChange:Boolean = true):Array {
				var self:InteractivityUser = room.getSelfUser();
				var menu:Array = [];
				menu.push(buildModerationMenuItem("Gag", "gag", targetUser, false, 5, allowChange && self.hasPermission(UserPermission.CAN_GAG)));
				menu.push(buildModerationMenuItem("Pin", "pin", targetUser, false, 5, allowChange && self.hasPermission(UserPermission.CAN_PIN)));
				menu.push(buildModerationMenuItem("Block Avatars", "block_avatars", targetUser, false, 15, allowChange && self.hasPermission(UserPermission.CAN_BLOCK_AVATARS)));
				menu.push(buildModerationMenuItem("Block Webcam", "block_webcams", targetUser, false, 60, allowChange && self.hasPermission(UserPermission.CAN_BLOCK_WEBCAMS)));
				menu.push(buildModerationMenuItem("Block Props", "block_props", targetUser, false, 15, allowChange && self.hasPermission(UserPermission.CAN_BLOCK_PROPS)));
				menu.push(buildModerationMenuItem("Ban User", "ban", targetUser, false, 1440, allowChange && self.hasPermission(UserPermission.CAN_BAN)));
				return menu;
			}
			
			private function buildGlobalModerationSubmenuItems(targetUser:InteractivityUser, allowChange:Boolean = true):Array {
				var self:InteractivityUser = room.getSelfUser();
				var menu:Array = [];
				menu.push(buildModerationMenuItem("Gag", "gag", targetUser, true, 5, allowChange && self.hasGlobalPermission(UserPermission.CAN_GAG)));
				menu.push(buildModerationMenuItem("Pin", "pin", targetUser, true, 5, allowChange && self.hasGlobalPermission(UserPermission.CAN_PIN)));
				menu.push(buildModerationMenuItem("Block Avatars", "block_avatars", targetUser, true, 15, allowChange && self.hasGlobalPermission(UserPermission.CAN_BLOCK_AVATARS)));
				menu.push(buildModerationMenuItem("Block Webcam", "block_webcams", targetUser, true, 60, allowChange && self.hasGlobalPermission(UserPermission.CAN_BLOCK_WEBCAMS)));
				menu.push(buildModerationMenuItem("Block Props", "block_props", targetUser, true, 15, allowChange && self.hasGlobalPermission(UserPermission.CAN_BLOCK_PROPS)));
				menu.push(buildModerationMenuItem("Ban User", "ban", targetUser, true, 1440, allowChange && self.hasGlobalPermission(UserPermission.CAN_BAN)));
				return menu;
			}
			
			private function buildModerationMenuItem(
				displayName:String,
				name:String,
				targetUser:InteractivityUser,
				global:Boolean,
				defaultMinutes:int = 5,
				allowChange:Boolean = true):Object
			{
				function durationItem(displayName:String, minutes:int):Object {
					return {
						type: 'normal',
						label: displayName,
						action: 'moderation',
						user: targetUser,
						data: {
							name: name,
							global: global,
							duration: minutes
						}
					};
				};
				
				var restrictionActive:Boolean;
				if (global) {
					restrictionActive = targetUser.hasGlobalRestriction(name);
				}
				else {
					restrictionActive = targetUser.hasWorldRestriction(name);
				}
				
				var timeOptions:Array;
				if (allowChange) {
					timeOptions = [
						durationItem("1 Minute", 1),
						durationItem("5 Minutes", 5),
						durationItem("15 Minutes", 15),
						durationItem("30 Minutes", 30),
						durationItem("1 Hour", 60),
						durationItem("6 Hours", 360),
						durationItem("1 Day", 1440),
						durationItem("7 Days", 10080),
						durationItem("30 Days", 43200),
						durationItem("1 Year", 525600),
						durationItem("5 Years", 2628000)
					];
				
					if (restrictionActive) {
						var cancelItem:Object = (durationItem("Cancel Restriction", 0));
	//					var self:InteractivityUser = room.getSelfUser();
	//					if (!self.hasPermission(UserPermission.CAN_REDUCE_RESTRICTION_TIME)) {
	//						cancelItem.enabled = false;
	//					}
						timeOptions.unshift(cancelItem);
					}
					
					timeOptions.unshift({ type: "separator" });
					timeOptions.unshift({ type: "normal", label: displayName, enabled: false });
				}
				
				if (restrictionActive) {
					var restriction:UserRestriction;
					if (global) {
						restriction = targetUser.getGlobalRestriction(name);
					}
					else {
						restriction = targetUser.getWorldRestriction(name);
					}
					if (restriction) {
						var formatter:DateFormatter = new DateFormatter();
						formatter.formatString = "MMM D, YYYY, L:NN A";
						displayName += " (expires " + formatter.format(restriction.expires) + ")";
					}
				}
				
				return {
					type: 'check',
					toggled: restrictionActive,
					enabled: allowChange,
					label: displayName,
					action: 'moderation',
					user: targetUser,
					data: {
						name: name,
						global: global,
						duration: defaultMinutes
					},
					children: timeOptions
				};
			}

			private function handleAvatarShowContextMenu(event:AvatarSelectEvent):void {
				if (currentMenu) {
					currentMenu.hide();
				}
				
				var user:InteractivityUser = room.getUserById(event.userId);
				
				var menuData:Array = [];
				if (room.selectedUser != user) {
					menuData.push({ type: 'normal', label: 'Whisper to ' + user.name, action: 'whisper', user: user});
				}
				else {
					menuData.push({ type: 'normal', label: 'Stop whispering to ' + user.name, action: 'stopWhispering', user: user});
				}
				
				if (!FriendsList.getInstance().getFriendsListEntryByGuid(user.id)) {
					menuData.push({ type: 'normal', label: 'Add ' + user.name + ' as friend', action: 'addFriend', user: user}); 
				}
				else {
					menuData.push({ type: 'normal', label: 'Unfriend ' + user.name, action: 'removeFriend', user: user}); 
				}
				
				menuData = menuData.concat(buildModerationMenuItems(user));
				
				currentMenu = Menu.createMenu(null, menuData, true);
				currentMenu.show(0,0);
				currentMenu.hide();
				
				var showY:Number = stage.mouseY;
				var showX:Number = stage.mouseX;
				
				var screen:Rectangle = systemManager.getVisibleApplicationRect(null, true);
				var menuHeight:Number = currentMenu.getExplicitOrMeasuredHeight();
				var menuWidth:Number = currentMenu.getExplicitOrMeasuredWidth();
				
				// Check for vertical clipping
				var shift:Number = stage.mouseY + menuHeight - screen.bottom;
				if (shift > 0 || stage.mouseY < screen.y) {
					showY = Math.max(showY - shift, 0);
				}
				
				// Check for horizontal clipping
				if (menuWidth + showX > screen.right) {
					showX -= menuWidth;
				}
				
				currentMenu.addEventListener(MenuEvent.ITEM_CLICK, handleUserContextMenuItemClick, false, 0, true);
				currentMenu.show(showX, showY);
			}
			
			private function handleUserContextMenuItemClick(event:MenuEvent):void {
				var interactivityUser:InteractivityUser;
				var worlizeNotification:WorlizeNotification;
				switch (event.item.action) {
					case "moderation":
						(new ApplyModerationRestrictionCommand()).execute(
							event.item.user.id,
							event.item.data.name,
							event.item.data.duration,
							event.item.data.global,
							InteractivityClient.getInstance().currentWorld.guid
						);
						break;
					case "blessModerator":
						Alert.show(
							"Are you sure you want to grant moderation privileges to " + event.item.user.name + "?",
							"Confirmation",
							Alert.YES | Alert.NO,
							null,
							function(closeEvent:CloseEvent):void {
								if (closeEvent.detail === Alert.YES) {
									var command:BlessUserAsModeratorCommand = new BlessUserAsModeratorCommand();
									command.execute(event.item.user.id, InteractivityClient.getInstance().currentWorld.guid);
								}
							}
						);
						break;
					case "unblessModerator":
						Alert.show(
							"Are you sure you want to revoke moderation privileges from " + event.item.user.name + "?",
							"Confirmation",
							Alert.YES | Alert.NO,
							null,
							function(closeEvent:CloseEvent):void {
								if (closeEvent.detail === Alert.YES) {
									var command:UnblessUserAsModeratorCommand = new UnblessUserAsModeratorCommand();
									command.execute(event.item.user.id, InteractivityClient.getInstance().currentWorld.guid);
								}
							}
						);
						break;
					case "whisper":
						interactivityUser = InteractivityUser(event.item.user);
						room.selectedUser = interactivityUser;
						worlizeNotification = new WorlizeNotification(WorlizeNotification.FOCUS_CHAT_BOX_NOTIFICATION);
						NotificationCenter.postNotification(worlizeNotification);
						break;
					case "stopWhispering":
						room.selectedUser = null;
						worlizeNotification = new WorlizeNotification(WorlizeNotification.FOCUS_CHAT_BOX_NOTIFICATION);
						NotificationCenter.postNotification(worlizeNotification);
						break;
					case "removeFriend":
						interactivityUser = InteractivityUser(event.item.user);
						var entry:FriendsListEntry = FriendsList.getInstance().getFriendsListEntryByGuid(interactivityUser.id);
						var message:String;
						var name:String
						if (entry.friendType === FriendsListEntry.TYPE_FACEBOOK && entry.autoSynced) {
							name = entry.name;
							message = name + " is from your Facebook friends list and was automatically added.\n\n" +
								"Are you sure you want to unfriend them?";
						}
						else {
							name = entry.username;
							message = "Are you sure you want to remove " + name + " from your friends list?"; 
						}
						Alert.show(message,
							"Unfriend " + name,
							Alert.YES | Alert.NO,
							null,
							function(event:CloseEvent):void {
								if (event.detail == Alert.YES) {
									entry.unfriend();
								}
							},
							null,
							Alert.NO
						);
						break;
					case "addFriend":
						interactivityUser = InteractivityUser(event.item.user);
						var userSearchResult:UserSearchResultLineItem = new UserSearchResultLineItem();
						userSearchResult.username = interactivityUser.name;
						userSearchResult.guid = interactivityUser.id;
						userSearchResult.addAsFriend();
						break;
					default:
						break;
				}
			}
			
			private function updateAvatarTransparencies():void {
				//trace("Updating avatar transparencies");
				for each (var avatar:Object in avatarsByUser) {
					var av:Avatar = Avatar(avatar);
					if (room.selectedUser == null || av.user.id == room.selfUserId || av.user == room.selectedUser) {
						//trace("User " + av.user.id + " is self or selected user or no user is selected");
						av.alpha = 1;
					}
					else {
						//trace("User " + av.user.id + " is not the selected user (" + room.selectedUser.id + ")");
						av.alpha = 0.6;
					}
				}
			}
			
			private var stickyMessagesByUser:Dictionary = new Dictionary();
			private var currentlyDisplayedChatMessages:ArrayCollection = new ArrayCollection();
			private var chatQueue:Array = [];
			
			private function handleChat(event:ChatEvent):void {
				if (event.soundName) {
					SoundPlayer.getInstance().playSound(event.soundName);
				}
				
				if (event.logOnly || event.chatText.length < 1) { return; }
				
				var message:ChatMessage = new ChatMessage();
				message.isWhisper = event.whisper;
				message.bubbleStyle = event.bubbleStyle;
				message.text = event.chatText;
				
				message.tint = event.user ? Avatar.chatBubbleTintColors[event.user.color] : 0xF9F9F9;
				message.user = event.user;
				if (event.locationSet) {
					message.x = event.x;
					message.y = event.y;
				}
				else if (event.user) {
					message.x = event.user.x;
					message.y = event.user.y - (avatarsByUser[event.user] as Avatar).avatarHeight/1.5 + 35;
				}
				else {
					message.x = 0;
					message.y = 35;
				}
				
				var notification:VisualNotification;
				if (!ExternalInterface.call('checkIsFocused') && message.user && message.user.id !== room.selfUserId) {
					if (message.isWhisper) {
						SoundPlayer.getInstance().playWhisperBell();
						notification = new VisualNotification();
						notification.onlyUseNative = true;
						notification.onlyWhenInactive = true;
						notification.titleFlashText = "Whisper from " + event.user.name;
						notification.title = "Whisper from " + event.user.name;
						notification.text = event.chatText;
						notification.show();
					}
					else {
						var shortText:String = event.chatText.slice(0, Math.max(event.chatText.length, 25));
						if (shortText.length < event.chatText.length) {
							shortText += "...";
						}
						notification = new VisualNotification();
						notification.titleFlashText = event.user.name + " says: " + shortText;
						notification.show();
					}
				}
				
				chatQueue.push(message);
				
				checkChatQueue();
			}
			
			private function checkChatQueue():void {
				var itemsInQueue:int = chatQueue.length;
				
				for (var i:int = 0; i < itemsInQueue; i ++) {
					var message:ChatMessage = chatQueue.shift();
					if (!displayChatBubble(message)) {
						// If we're not currently able to display the chat bubble,
						// put it back on the queue.
						//trace("Didn't successfully display message.");
						message.displayFailureCount ++;
						if (message.displayFailureCount < 40) {
							chatQueue.push(message);
						}
					}
				}
			}
			
			// return true for success, false to put it back on the queue
			private function displayChatBubble(message:ChatMessage):Boolean {
				
				if (message.user && stickyMessagesByUser[message.user]) {
					var oldMessage:ChatMessage = stickyMessagesByUser[message.user];
					delete stickyMessagesByUser[oldMessage.user];
					var index:int = currentlyDisplayedChatMessages.getItemIndex(oldMessage);
					currentlyDisplayedChatMessages.removeItemAt(index);
					textGroup.removeElement(oldMessage.chatBubble);
				}
				
				var chatBubble:ChatBubble = new ChatBubble();
				switch(message.bubbleStyle) {
					case ChatBubbleStyle.THOUGHT:
						chatBubble.setStyle('skinClass', Class(com.worlize.interactivity.view.ThoughtBubbleSkin));
						break;
					case ChatBubbleStyle.EXCLAMATION:
						chatBubble.setStyle('skinClass', Class(com.worlize.interactivity.view.SpikeyBubbleSkin));
						break;
					case ChatBubbleStyle.STICKY:
						chatBubble.setStyle('skinClass', Class(com.worlize.interactivity.view.StickyBubbleSkin));
						break;
					default:
						chatBubble.setStyle('skinClass', Class(com.worlize.interactivity.view.ChatBubbleSkin));
						break;
				}
				chatBubble.text = message.text;
				chatBubble.x = message.x;
				chatBubble.y = message.y;
				chatBubble.mouseEnabled = false;
				chatBubble.isWhisper = message.isWhisper;
				chatBubble.tintColor = message.tint;
				chatBubble.visible = true;
				// Compensate for room size reduction, if applied
				if (scaleX !== 1.0) {
					chatBubble.scaleX = 1 / scaleX;
				}
				if (scaleY !== 1.0) {
					chatBubble.scaleY = 1 / scaleY;
				}
				
				var overlapped:Boolean = false;
				
				// Check for overlaps...
				textGroup.addElement(chatBubble)
				chatBubble.validateNow();
				for (var positionNumber:int = 0; positionNumber < 4; positionNumber ++) {
					overlapped = false;

					// Check if we're running off the edge of the screen
					//trace(chatBubble.skin.currentState);

					var skinState:String = chatBubble.skin.currentState;
					var rightCheck:Number, leftCheck:Number, bottomCheck:Number, topCheck:Number;
					var inverseScaleFactor:Number = 1 / scaleFactor;
					
					if (skinState.indexOf('Right') != -1) {
						rightCheck = chatBubble.x + chatBubble.skin.x + (chatBubble.skin.measuredWidth * inverseScaleFactor);
						leftCheck = chatBubble.x + chatBubble.skin.x;
					}
					if (skinState.indexOf('Left') != -1) {
						rightCheck = chatBubble.x + chatBubble.skin.x;
						leftCheck = chatBubble.x + chatBubble.skin.x - (chatBubble.skin.measuredWidth * inverseScaleFactor);
					}
					if (skinState.indexOf('bottom') != -1) {
						bottomCheck = chatBubble.y + chatBubble.skin.y + (chatBubble.skin.measuredHeight * inverseScaleFactor);
						topCheck = chatBubble.y + chatBubble.skin.y;
					}
					if (skinState.indexOf('top') != -1) {
						bottomCheck = chatBubble.y + chatBubble.skin.y;
						topCheck = chatBubble.y + chatBubble.skin.y - (chatBubble.skin.measuredHeight * inverseScaleFactor);
					}
					 
					if (
							rightCheck > width ||
							bottomCheck > (height - 26) ||
							leftCheck < 0 ||
							topCheck < 0
					   ) { 
					   	overlapped = true;
						chatBubble.tryNextPosition();
						chatBubble.validateNow();
						continue;
					}
					
					for (var i:int = 0; i < currentlyDisplayedChatMessages.length; i ++) {
						var m:ChatMessage = ChatMessage(currentlyDisplayedChatMessages.getItemAt(i));
						if (!m.isStickyBubble && m.chatBubble.hitTestObject(chatBubble)) {
							overlapped = true;
							chatBubble.tryNextPosition();
							chatBubble.validateNow();
							break;
						}
					}
					if (!overlapped) {
						break;
					}
				}
				
				if (overlapped) {
					//trace("unresolvable overlap detected.");
					textGroup.removeElement(chatBubble);
					return false;
				}
				
				chatBubble.visible = true;
				message.chatBubble = chatBubble;
				
				if (!message.isStickyBubble) {
					message.hideTimeout = setTimeout(removeChatBubble, 3000 + (message.text.length * 70), message);
				}
				else if (message.user) {
					stickyMessagesByUser[message.user] = message;
				}
				currentlyDisplayedChatMessages.addItem(message);
				return true;
			}
			
			private function removeChatBubblesForUser(user:InteractivityUser):void {
				var i:int;
				var chatMessage:ChatMessage;
				// De-queue any pending chat bubbles first
				for (i = chatQueue.length - 1; i >= 0; i --) {
					chatMessage = ChatMessage(chatQueue[i]);
					if (chatMessage.user) {
						if (chatMessage.user.id === user.id) {
							chatQueue.splice(i, 1);
						}
					}
				}
				
				// Then remove any sticky bubbles
				chatMessage = stickyMessagesByUser[user];
				if (chatMessage != null) {
					var index:int = currentlyDisplayedChatMessages.getItemIndex(chatMessage);
					currentlyDisplayedChatMessages.removeItemAt(index);
					textGroup.removeElement(chatMessage.chatBubble);
					delete stickyMessagesByUser[user];
				}
				
				// Then get rid of all other kinds
				for (i = currentlyDisplayedChatMessages.length - 1; i >= 0; i --) {
					chatMessage = ChatMessage(currentlyDisplayedChatMessages.getItemAt(i));
					if (chatMessage.user) {
						if (chatMessage.user.id === user.id) {
							removeChatBubble(chatMessage);
						}
					}
				}
			}
			
			private function removeChatBubble(message:ChatMessage):void {
				try {
					if (message.hideTimeout) {
						clearTimeout(message.hideTimeout);
						message.hideTimeout = 0;
					}
					var fade:Fade = new Fade(message.chatBubble);
					fade.duration = 300;
					fade.alphaFrom = 1;
					fade.alphaTo = 0;
					fade.addEventListener(EffectEvent.EFFECT_END, handleChatBubbleFadeComplete);
					fade.play();
					currentlyDisplayedChatMessages.removeItemAt(currentlyDisplayedChatMessages.getItemIndex(message));
				}
				catch (e:Error) { /* do nothing */ }
				
				checkChatQueue();
			}
			
			private function handleChatBubbleFadeComplete(event:EffectEvent):void {
				var bubble:ChatBubble = ChatBubble(Animate(event.target).target);
				try {
					textGroup.removeElement(bubble);
				}
				catch(e:Error) {
					logger.warn("Unable to remove element after fadeout animation.  Chat message: " + bubble.text + " - [" + bubble + "]");
					// do nothing
				}
			}
			
			private function handleUserEntered(event:RoomEvent):void {
				var avatar:Avatar = new Avatar();
				avatar.user = event.user;
				avatar.alpha = 1;
				avatar.netConnectionManager = netConnectionManager;
				avatar.webcamBroadcastManager = webcamBroadcastManager;
				avatar.addEventListener(AvatarSelectEvent.SHOW_CONTEXT_MENU, handleAvatarShowContextMenu);
				avatar.addEventListener(MouseEvent.MOUSE_DOWN, handleAvatarDragMouseDown);
				avatarsGroup.addElement(avatar);
				avatar.validateDisplayList();
				avatarsByUser[event.user] = avatar;
				updateAvatarTransparencies();
				
				var nameTag:NameTag = new NameTag();
				nameTag.user = event.user;
				nameTagsByUser[event.user] = nameTag;
				nameTag.alpha = 0;
				if (scaleX !== 1.0) {
					nameTag.scaleX = 1 / scaleX;
					nameTag.scaleY = 1 / scaleY;
				}
				nameTagGroup.addElement(nameTag);
				
				var fade:Fade = new Fade(nameTag);
				fade.duration = 700;
				fade.startDelay = int(Math.random() * 400);
				fade.alphaFrom = 0;
				fade.alphaTo = 1;
				fade.play();
			}
			
			private function handleUserLeft(event:RoomEvent):void {
				var avatar:Avatar = avatarsByUser[event.user];
				if (avatar != null) {
					avatar.removeEventListener(AvatarSelectEvent.AVATAR_SELECT, handleAvatarShowContextMenu);
					avatar.removeEventListener(MouseEvent.MOUSE_DOWN, handleAvatarDragMouseDown);
					avatarsGroup.removeElement(avatar);
					delete avatarsByUser[event.user];
				}
								
				var nameTag:NameTag = nameTagsByUser[event.user];
				if (nameTag != null) {
					nameTagGroup.removeElement(nameTag);
					delete nameTagsByUser[event.user];
				}
				
				removeChatBubblesForUser(event.user);
			}
			
			private function handleRoomCleared(event:RoomEvent):void {
				for each (var avatar:Object in avatarsByUser) {
					Avatar(avatar).removeEventListener(MouseEvent.MOUSE_DOWN, handleAvatarShowContextMenu);
					Avatar(avatar).removeEventListener(MouseEvent.MOUSE_DOWN, handleAvatarDragMouseDown);
				}
				avatarsGroup.removeAllElements();
				avatarsByUser = new Dictionary();

				nameTagGroup.removeAllElements();
				nameTagsByUser = new Dictionary();
				
				currentlyDisplayedChatMessages.removeAll();
				chatQueue = [];
				textGroup.removeAllElements();
				
			}

			private function handleBGChange(event:PropertyChangeEvent):void {
				currentState = "normal";
				backgroundImage.visible = false;
				roomFader.alpha = 1;
				if (room.backgroundFile == null) {
					return;
				}
				if (backgroundImage.source == room.backgroundFile) {
					handleBackgroundLoadComplete();
				}
				else {
					backgroundImage.source = room.backgroundFile;
				}
				if (backgroundImage.content) {
					backgroundImage.visible = true;
				}
			}
			
			private function handleBackgroundLoadComplete(event:Event=null):void {
				if (InteractivityConfig.fadeBackgroundImages) { 
					var fade:Fade = new Fade(roomFader);
					fade.duration = 200;
					fade.alphaFrom = 1;
					fade.alphaTo = 0;
					fade.play();
					
					currentState = "normal";
				}
				backgroundImage.visible = true;
				backgroundImage.smoothBitmapContent = false;
				backgroundImage.smoothBitmapContent = true;
			}
			
			private function handleUnableToLoadBG():void {
				backgroundImage.source = null;
				currentState = "unableToLoadBackground";
			}
			
			private function handleBGioERROR(event:IOErrorEvent):void {
				handleUnableToLoadBG();
			}
			
			private function handleSecurityError(event:SecurityErrorEvent = null):void {
				var security_event:InteractivitySecurityErrorEvent = new InteractivitySecurityErrorEvent(InteractivitySecurityErrorEvent.SECURITY_ERROR);
				dispatchEvent(event);
			}
			
			private var lastX:Number = 0;
			private var lastY:Number = 0;
			private function handleEnterFrame():void {
				if (mouseX < 0 || mouseX > 950 || mouseY < 0 || mouseY > 570) { return; }
				if (lastX !== mouseX || lastY !== mouseY) {
					lastX = mouseX;
					lastY = mouseY;
					dispatchEvent(new MouseEvent("customMouseMove", false, false, mouseX, mouseY, null, false, false, false, false, 0));
				}
			}
			
			public function snapshot():BitmapData {
				var bitmapData:BitmapData = new BitmapData(width, height, false);
				try {
					bitmapData.draw(this);
				}
				catch(e:Error) {
					return null;
				}
				return bitmapData;
			}
			
			public function snapshotJPEG():ByteArray {
				var encoder:JPEGEncoder = new JPEGEncoder(90);
				return encoder.encode(snapshot());
			}
			
		]]>
	</fx:Script>
	
	<s:Rect width="100%" height="100%">
		<s:fill>
			<s:SolidColor color="#f0f0f1" />
		</s:fill>
	</s:Rect>
	
	<mx1:Image top="0" left="0" id="backgroundImage"
        width="950" height="570"
		smoothBitmapContent="true"
		scaleContent="false" complete="handleBackgroundLoadComplete(event)"
		loaderContext="{InteractivityClient.loaderContext}" securityError="handleSecurityError(event)" ioError="handleBGioERROR(event);"
		visible="false" />
	
	<s:Label text="Unable to load background." width="90%"
			 mouseEnabled="false"
			 color="#FFFFFF" fontSize="15"
			 includeIn="unableToLoadBackground"
			 textAlign="center"
			 verticalCenter="0" horizontalCenter="0" />

	<!--
	<view:InWorldObjectLayer id="inWorldObjectLayer" inWorldObjects="{room.inWorldObjects}" 
							 top="0" left="0" right="0" bottom="0" />
	
	<view:YouTubePlayersLayer youTubePlayerDefinitions="{room.youtubePlayers}" />

	<view:HotspotsLayer id="hotSpotCanvas"
							hotSpots="{room.items}" top="0" right="0" bottom="0" left="0"
							/>
	-->

	<view:ItemsView id="itemsViewLayer" items="{room.items}" />
	
	<view:LoosePropsLayer id="loosePropsLayer"
						  propList="{room.loosePropList}"
						  top="0" left="0" right="0" bottom="0" />
	
	<s:Rect width="100%" height="100%">
		<s:fill>
			<s:SolidColor color="0x000000" alpha="{1 - room.dimLevel}" />
		</s:fill>
	</s:Rect>
	
	<s:Rect width="100%" height="100%" visible.unableToLoadBackground="false"
			id="roomFader" alpha="0">
		<s:fill>
			<s:SolidColor color="#f0f0f1" />
		</s:fill>
	</s:Rect>
	
	<s:Group id="avatarsGroup" top="0" right="0" bottom="0" left="0"
			 mouseChildren="{room.showAvatars}"
			 mouseEnabled="{room.showAvatars}"
			 visible="{room.showAvatars}">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>
	
	<s:SpriteVisualElement id="snowContainer" mouseEnabled="false" mouseChildren="false"
						   top="0" right="0" bottom="0" left="0" />

	<s:Group id="nameTagGroup" mouseEnabled="false"
			 mouseChildren="false"
			 visible="{room.showAvatars}">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>
	
	<s:Group id="textGroup" mouseEnabled="false" mouseChildren="false"
			 top="0" right="0" bottom="0" left="0">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>
	
	<mx1:ProgressBar
		width="950"
		bottom="25"
		source="{backgroundImage}"
		visible="{backgroundImage.source != null &amp;&amp; progressBar.percentComplete &lt; 100}"
		labelPlacement="center"
		id="progressBar"
		label="Downloading Background... {Math.ceil(progressBar.percentComplete)}%" />
	
	
</s:Group>
