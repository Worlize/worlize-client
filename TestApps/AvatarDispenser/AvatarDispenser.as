package  {		import flash.display.MovieClip;	import com.worlize.api.WorlizeAPI;	import flash.events.MouseEvent;	import com.worlize.api.model.Avatar;	import com.worlize.api.event.ChangeEvent;	import com.worlize.api.event.UserEvent;	import flash.utils.setTimeout;	import com.worlize.api.event.AuthorEvent;			public class AvatarDispenser extends MovieClip {		public var api:WorlizeAPI;				private var currentIndex:int = -1;				private var avatars:Array = [];				public function AvatarDispenser() {			WorlizeAPI.options.editModeSupported = true;			api = WorlizeAPI.init(this);						prevButton.addEventListener(MouseEvent.CLICK, handlePrevClick);			nextButton.addEventListener(MouseEvent.CLICK, handleNextClick);			addButton.visible = false;						resetFromConfig();			syncCurrentIndex();			updateCountDisplay();						api.addEventListener(AuthorEvent.EDIT_MODE_ENABLED, handleEditModeEnabled);			api.addEventListener(AuthorEvent.EDIT_MODE_DISABLED, handleEditModeDisabled);			api.config.addEventListener(ChangeEvent.PROPERTY_CHANGED, handleConfigChanged);			api.thisUser.addEventListener(UserEvent.USER_AVATAR_CHANGED, handleAvatarChanged);		}				private function handleEditModeEnabled(event:AuthorEvent):void {			addButton.addEventListener(MouseEvent.CLICK, handleAddClick);			addButton.visible = true;		}				private function handleEditModeDisabled(event:AuthorEvent):void {			addButton.removeEventListener(MouseEvent.CLICK, handleAddClick);			addButton.visible = false;		}				private function resetFromConfig():void {			if (api.config.data.avatars is Array) {				avatars = api.config.data.avatars;				currentIndex = -1;				updateCountDisplay();			}		}				private function handleConfigChanged(event:ChangeEvent):void {			if (event.changedBy !== api.thisUser) {				resetFromConfig();			}		}				private function handlePrevClick(event:MouseEvent):void {			trace("Prev clicked");			if (currentIndex > 0) {				currentIndex --;				wearCurrentAvatar();				updateCountDisplay();			}		}				private function handleNextClick(event:MouseEvent):void {			trace("Next clicked");			if (currentIndex < avatars.length-1) {				currentIndex ++;				wearCurrentAvatar();				updateCountDisplay();			}		}				private function wearCurrentAvatar():void {			if (currentIndex < avatars.length) {				api.thisUser.setAvatar(avatars[currentIndex]);			}		}				private function handleAddClick(event:MouseEvent):void {			trace("Add clicked");			if (api.thisUser.canAuthor) {				if (api.thisUser.avatar.type !== Avatar.TYPE_IMAGE) {					api.thisRoom.localAnnounce("You must be wearing the avatar you wish to save.");					return;				}								var avatar:Avatar = api.thisUser.avatar;								if (avatars.indexOf(avatar.guid) === -1) {					avatars.push(avatar.guid);										syncCurrentIndex();					updateCountDisplay();										api.config.data.avatars = avatars;					api.config.save();				}			}			else {				api.thisRoom.localAnnounce("Only room authors can add avatars.");			}		}				private function handleAvatarChanged(event:UserEvent):void {			syncCurrentIndex();			updateCountDisplay();		}				private function syncCurrentIndex():void {			if (api.thisUser.avatar.type === Avatar.TYPE_IMAGE) {				currentIndex = avatars.indexOf(api.thisUser.avatar.guid);			}			else {				currentIndex = -1;			}		}				private function updateCountDisplay():void {			if (avatars.length > 0) {				countText.text = (currentIndex + 1) + "/" + avatars.length;			}			else {				countText.text = "0/0";			}		}	}	}