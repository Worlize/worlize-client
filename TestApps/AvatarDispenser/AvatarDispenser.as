package  {		import flash.display.MovieClip;	import com.worlize.api.WorlizeAPI;	import flash.events.MouseEvent;	import com.worlize.api.model.Avatar;	import com.worlize.api.event.ChangeEvent;	import com.worlize.api.event.UserEvent;	import flash.utils.setTimeout;	import com.worlize.api.event.AuthorEvent;	import com.worlize.api.constants.AvatarType;			public class AvatarDispenser extends MovieClip {		public var api:WorlizeAPI;				private var currentIndex:int = -1;				private var avatars:Array = [];				public function AvatarDispenser() {			WorlizeAPI.options.editModeSupported = true;			WorlizeAPI.options.name = "Simple Avatar Dispenser";			api = WorlizeAPI.init(this);						prevButton.addEventListener(MouseEvent.CLICK, handlePrevClick);			nextButton.addEventListener(MouseEvent.CLICK, handleNextClick);			addButton.addEventListener(MouseEvent.CLICK, handleAddClick);						addButton.visible = addButton.mouseEnabled = api.editMode;			delButton.visible = delButton.mouseEnabled = api.editMode;						addButton.addEventListener(MouseEvent.CLICK, handleAddClick);			delButton.addEventListener(MouseEvent.CLICK, handleDelClick);						resetFromConfig();			syncCurrentIndex();			updateCountDisplay();			checkDisplayAuthorButton();						api.addEventListener(AuthorEvent.EDIT_MODE_ENABLED, handleEditModeEnabled);			api.addEventListener(AuthorEvent.EDIT_MODE_DISABLED, handleEditModeDisabled);			api.config.addEventListener(ChangeEvent.PROPERTY_CHANGED, handleConfigChanged);			api.thisUser.addEventListener(UserEvent.USER_AVATAR_CHANGED, handleAvatarChanged);		}				private function handleEditModeEnabled(event:AuthorEvent):void {			checkDisplayAuthorButton();		}				private function handleEditModeDisabled(event:AuthorEvent):void {			checkDisplayAuthorButton();		}				private function checkDisplayAuthorButton():void {			if (api.editMode) {				if (api.thisUser.avatar.type !== AvatarType.IMAGE ||					avatars.indexOf(api.thisUser.avatar.guid) === -1)				{					addButton.visible = addButton.mouseEnabled = true;					delButton.visible = delButton.mouseEnabled = false;				}				else {					addButton.visible = addButton.mouseEnabled = false;					delButton.visible = delButton.mouseEnabled = true;				}			}			else {				addButton.visible = addButton.mouseEnabled = false;				delButton.visible = delButton.mouseEnabled = false;			}		}				private function resetFromConfig():void {			if (api.config.data.avatars is Array) {				avatars = api.config.data.avatars;				currentIndex = -1;				updateCountDisplay();			}		}				private function handleConfigChanged(event:ChangeEvent):void {			if (event.changedBy !== api.thisUser) {				resetFromConfig();			}		}				private function handlePrevClick(event:MouseEvent):void {			if (currentIndex > 0) {				currentIndex --;				wearCurrentAvatar();				updateCountDisplay();			}			else if (avatars.length > 0) {				currentIndex = avatars.length - 1;				wearCurrentAvatar();				updateCountDisplay();			}		}				private function handleNextClick(event:MouseEvent):void {			if (currentIndex < avatars.length-1) {				currentIndex ++;				wearCurrentAvatar();				updateCountDisplay();			}			else if (avatars.length > 0) {				currentIndex = 0;				wearCurrentAvatar();				updateCountDisplay();			}		}				private function wearCurrentAvatar():void {			if (currentIndex < avatars.length) {				var guid:String = avatars[currentIndex];				if (guid) {					api.thisUser.setAvatar(avatars[currentIndex]);				}			}		}				private function handleAddClick(event:MouseEvent):void {			trace("Add clicked");			if (api.thisUser.canAuthor) {				if (api.thisUser.avatar.type !== AvatarType.IMAGE) {					api.thisRoom.announceLocal("You must be wearing the avatar you wish to save.");					return;				}								var avatar:Avatar = api.thisUser.avatar;								if (avatars.indexOf(avatar.guid) === -1) {					avatars.push(avatar.guid);										syncCurrentIndex();					updateCountDisplay();					checkDisplayAuthorButton();										api.config.data.avatars = avatars;					api.config.save();				}			}			else {				api.thisRoom.announceLocal("Only room authors can add avatars.");			}		}				private function handleDelClick(event:MouseEvent):void {			trace("Del clicked");			if (api.thisUser.canAuthor) {				if (api.thisUser.avatar.type !== AvatarType.IMAGE) {					return;				}								var avatar:Avatar = api.thisUser.avatar;								var index:int = avatars.indexOf(avatar.guid);				if (index === -1) {					return;				}				avatars.splice(index, 1);								if (currentIndex === avatars.length && currentIndex > 0) {					currentIndex --;				}				wearCurrentAvatar();				updateCountDisplay();				checkDisplayAuthorButton();								api.config.data.avatars = avatars;				api.config.save();			}		}				private function handleAvatarChanged(event:UserEvent):void {			syncCurrentIndex();			updateCountDisplay();			checkDisplayAuthorButton();		}				private function syncCurrentIndex():void {			if (api.thisUser.avatar.type === AvatarType.IMAGE) {				currentIndex = avatars.indexOf(api.thisUser.avatar.guid);			}			else {				currentIndex = -1;			}		}				private function updateCountDisplay():void {			if (avatars.length > 0) {				countText.text = (currentIndex + 1) + "/" + avatars.length;			}			else {				countText.text = "0/0";			}		}	}	}